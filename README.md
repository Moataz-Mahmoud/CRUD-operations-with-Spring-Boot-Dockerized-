# Introduction
In this project, I have built a web app in Spring Boot. Spring Boot is a Java framework used to create web apps. This app simply is connecting to a database and performing the CRUD operations to it.
So let's dig deeper into the details.

# Connect the web app to the database
First of all, this project is connecting to a publicly shared database which is called postgres-world-db. This database is representing many countries and provides some details about each country such as the population, the area, the capital, and etc. This database is dockerized and shared on the docker-hub. You can get it from [here](<https://hub.docker.com/r/ghusta/postgres-world-db>).
The way that the web app is connecting to the database is the datasource.url property which is set in the [application.properties](https://github.com/Moataz-Mahmoud/CRUD-operations-with-Spring-Boot-Dockerized-/blob/master/country-web-app/src/main/resources/application.properties) file. This datasource url should point to localhost:portNumber/DB-name. But you will find that it's pointing to database:5432/world-db. The reason of that it refers to **database** instead of **localhost** is related to the docker-compose file which will be covered below.

# Perform the CRUD operations
After connecting to the database, the web app is ready to perform the CRUD operations.
All the operations are developed in [WebController](https://github.com/Moataz-Mahmoud/CRUD-operations-with-Spring-Boot-Dockerized-/blob/master/country-web-app/src/main/java/com/example/demo/controller/WebController.java) file.
At first, we need to map the whole class to /countries. This mapping lead you to call localhost:portNumber/countries/entryPoint to access any end point built below instead of localhost:portNumber/EntryPoint. And there are two advantages of such a trick:
- The first one is it's just a better practice to map the whole class in order not to concatinate the entry point name with the port number directly. 
- The second advantage is that Spring Boot is creating a default implementation to that class mapping. So that if you types localhost:8080/countries you will get the result of all the contents of the database. So you will get all the cointries objects in this case without writing even a single line of code. *Magnificent*!

Then, all the endpoints will be emplemented respectively. getCountryByCode, getAllCountries, createCountry, updateCountry, and finally deleteCountry.
All the end points are self-descriptive and commented with all its details.

The key idea in the web controller is to create a CountryRepository, and then use it to call many of the built in functions in it. Let's get a closer look on it from [here](https://github.com/Moataz-Mahmoud/CRUD-operations-with-Spring-Boot-Dockerized-/blob/master/country-web-app/src/main/java/com/example/demo/Repository/CountryRepository.java).
CountryRepository is a very primative class which all it does is extending a built in class in Spring Boot which is JPARepository. This class has too many ready functions which you can access directly to perform the CRUD operations as you can see in the web controller. You just need to give it the generic with two members. The first is the class which the functions of the repository will deal with it. The second is the id. This id will be used in the get functions. So if you provided it an integer id, so you will pass an integer variable to the function. If you provided a string one, you will get by string variable. And so on. The most important hint here is ***the type of the id must be as same as the primary key of the database table***. So in our example, because of that the type of the primary key is string "countryCode" we will provid the generic a string variable.

The last part to take a look on it is the Country class.
This class as you can see [here](https://github.com/Moataz-Mahmoud/CRUD-operations-with-Spring-Boot-Dockerized-/blob/master/country-web-app/src/main/java/com/example/demo/model/Country.java) is just for mapping porpuse. In this class you will define a variable for each attribute in the database table. Also you will need to define the two mutators (setter and getter) for each of them in order to access them.
The primary key of the table must be annotated with @Id annotation to diffrentiate it from the other attributes. That's the all about the model (Country) class. There is no need to define a custome constructor due to that the only point of code we will instantiate the country code is to save the JSON object retrieved by the entry points. And so the JSON object will set the values for you. 
If you look more carefully to both the defined attribute in the model and the already existing in the database, you will find that some attributes aren't there. Simply because I don't need to retrieve them from the databse. Also you can see that all the missed attributes are sometimes nullable, so if you added them to the model in the same way that I added the others, you will get a run time error saying that it's nullable sometimes. So you will need to add "nullable = true" to the annotation to solve such an exception.

# Dockerize the app
Now let's go to the most exciting part of the project. It's docker.
In the repository you can find two files which are related to docker. One is inside the web app and called "Dockerfile" and the other in the home directory and is called "docker-compose.yml". The name of the both are naming conversions. Which means that if you rename any of them, you won't be able to run the solution using docker-compose up command as we will see shortly.

**Just a quick intro to docker ...**
Docker is a tool which is used for the sake of portability and isolation. So once you dockerize your app, you can share it with others. And now all the others need to run this app is just to install docker and run your solution. No need for dependencies, no need for compatibility issues, versions, OS version, ...etc.
For example, this repo is building a java web app which is connecting to a postgres database. But once you clone this project, you won't need to install neither Java nor postgres to be able to run it. The only tool you need to install is docker itself. Also there is no importance what's the operating system you are using. Just install docker, navigate to the project directory via the terminal, and then type "docker-compose up". After that, set down and sip your tea mug and watch the magic which docker is doing for you until the app is upp and running.

##### Close look to the web app Dockerfile
As you can see, this solution consists of two main components. The web service and the database service. So you can conclude that to run it, we need to launch a docker container for the web app and another one for the database and let them communicate with each other to get the results.
Starting from the webservice, you need to create a docker image for this app to be standalone. And the way to do that is to create a Dockerfile in the home directory of the app. This docker file has a convinient structure. You can take a look on how to write it step by step from [this reference](https://docs.docker.com/engine/reference/builder/). But the good news here is that Spring Boot has a ready extension for doing that for you. It's a plugin built by [Spotify](https://www.spotify.com/) which you can view from [here](https://github.com/spotify/docker-maven-plugin). Once you follow the steps in their github repo, you will get the docker file of your project.

##### docker-compose.yml file
Now we have the docker image of the web service and need to build the docker image of the database. There are two approaches here:
 - As we did for the web service, we will create a Dockerfile for the database. Fortunately, who created it also dockerized it and share it on the docker-hub. You can pull it and then you have the ready image of the database.
 - But the second and most preferrable option, is using just by calling the service name and asks the docker-compose file to build this image and he will do it for you.

But wait, what's that docker-compose file, and why we need it?
Dokcercompse is like that part of docker which makes it that extremely revolutionary. You need docker-compose to let the docker images communicate with each others and arrange that communication process.
The docker compose file is defining all the containers which will be started, everyone as a service. And then thoughout too many options, you can orchestrate their communication. 
You can think about the docker compose syntax as the protocol which the images will use to communicate. ***As the web packets using the HTTP protocol to talk to each others over internet, docker containers use docker compose to talk to each others over something called docker network***. By default, the docker-compose file creates a default netwrok for your services, unless you define other networks and start using them. You can read more about docker networks from this [reference](https://blog.docker.com/2016/12/understanding-docker-networking-drivers-use-cases/).

To build the database image you can either write the syntax of docker image inside the database service's part in the docker-compose file, which is considered as rework. Or the better solution is to refer to the docker image on the docker hub and ask the compose file to instantiate a container of it. Then you need to map the ports of the docker image to your local port. The internal port of the database is 5432. You can map it to any port number you need. But just make sure that it's not used on your machine avoiding conflicts and compose errors.

That was the first section of the compose file, the database service.
The second section is the web service. And this service will build the Dockerfile you generated in the web app directory at first. Secondly, it will again map the ports, but this time it will map them for the web service. By default, a web app will be running on 8080, and you can also map it to any port you want. 

Now the docker-compose file can create and run the two containers. But there are still some additional steps to be done.
First, we don't need the web app to try to hit the database before it's ready for receiving it. So in the web service we add depends_on option and tell docker that the web service depends on the database one. And so docker compose will just instantiate the web app after the database is ready to avoid conflicts and unexpected behaviors.
Second, the web app container now don't know that there is another container for the database. So you need to link them to each other which is done by -link option in the docker-compose file.

The final note here that we have the default docker network containing two containers, one for the web app and the other to the database. So in any of them, if you tried to connect to localhost, you are connecting to two different localhosts. So you need to distinguish between the both when you type localhost in your browser.
To do so, you will tell the web app not to hit localhost:portNumber/Db-name to connect to the database. Instead you tell it to hit database:portnumber/Db-name where database is the name of the database service in the docker copmose file.

# Why I didn't get the full amusement creating this project in JAVA (Optional)

As a personal preference, I don't think that Spring Boot is the most suitable framework to do such a project. And there are many reasons for that actually: 
- Java is an old language. This leads to too much complexity and too many directories to accomplish a simple task. You can see that from the current project. It's just s tiny project implementing CRUD operations, but if you look to the project tree, you will say "Oh, Damn! how complex is it?". Modern lanuages such as Python and JavaScript tackling these tasks more straightforward. Those languages are much modern and keep up with the new technology trends more flixabally.
- It's actually related to the first point. Due to Java is old, it's not that flexible. So creating a new framework for a new development area in Java is much harder than in Python or JavaScript. And they put the maximum effort in utilizing it, it will be still lagging behind the competitors in other programming langues. You can get this conclusion if you look at a programming language like Python, and see how many perfect web frameworks and how flexibally is maintaining them. You can take a look [here](https://hackernoon.com/top-10-python-web-frameworks-to-learn-in-2018-b2ebab969d1a) for an example.
- What about the complexity of development?
In Java you need to keep tracking of too many components to do the same work as a single script of go language for example can do. There are too many dependencies and two many ways about configuring your application. And that makes it very hard for beginners to learn it fast. And makes it pretty hard for the professionals to trace the errors and get the root causes of bugs unless there are many shared areas instead of just a script.
- Another obious demirit of Java is that it's a static typing language. Many other languages -again because they are modern- support dynamic typing more powerfully and originally than Java. When they need Java to support dynamic typing, they build another programming languages, such as Groovy, running on Java Virtual Machine which leads to many performance issues. Also take a look [here](https://hackernoon.com/statically-typed-vs-dynamically-typed-languages-e4778e1ca55) for more insights.
- Let's talk about utilizing the resources. Java being running over JVM is a huge drawback. This leads to slowness, memory cost, limited latency critical tuning, and more. Also get a closer look from this [rich discussion] (https://www.youth4work.com/Talent/Core-Java/Forum/112601-what-are-disadvantages-of-java)
- Last but not least, as known for all of us, Java is a compiled language. Which is a drawback itself. As I pointed many times above, compilation is an old concept. The main advantage of the compiled languages that you just build once and can run as many times as you need. But this feature isn't an advantage anymore. On the other hand, the interpreted languages -which builds every time you run- are now fast enough to get the rid of the latency of building. Actually if you are running two applications, one is complied and the other is interpreted, you can't feel a huge difference between them in the running speed. And actually it's specifically which gives the interpreted languages the leadership here. Everytime you are editing your code, you can just run directly, no need to recompile or rebuild. And this is the requirement of the last ages. The world is fast now, and where you will be more dynamic and independent, you will feel that you are better. And that's the case of interpreted languages.

Finally, it's a life long depate between the compiled language fans and the interpreted language ones. Some are more flexible and prefers focus on the programming logic and the fast of edit process. And there are other who belong to the old school and still prefer Java.
It's not a big deal. At the end, the client won't ask you why you built my system in this language instead of that. But it's just a matter of preference.

Finally thanks for your time reading such a long readme file. And don't hisitate to contact me for any further comments or edits. **Thank you!**
